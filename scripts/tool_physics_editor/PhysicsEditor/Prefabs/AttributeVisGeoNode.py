### CapsuleGenGeoNode.py ###
# Automatically generated by NodeToPython Addon: https://github.com/BrendanParmer/NodeToPython/releases/tag/v2.2.0

import bpy

#initialize attr_vis node group
def attr_vis_node_group():
	attr_vis= bpy.data.node_groups.new(type = 'GeometryNodeTree', name = "Attr_Vis")

	#initialize attr_vis nodes
	#node Named Attribute.001
	named_attribute_001 = attr_vis.nodes.new("GeometryNodeInputNamedAttribute")
	named_attribute_001.data_type = 'FLOAT'

	#node Attribute Statistic
	attribute_statistic = attr_vis.nodes.new("GeometryNodeAttributeStatistic")
	attribute_statistic.data_type = 'FLOAT'
	attribute_statistic.domain = 'POINT'
	#Selection
	attribute_statistic.inputs[1].default_value = True
	#Attribute_001
	attribute_statistic.inputs[3].default_value = (0.0, 0.0, 0.0)

	#node Ico Sphere.001
	ico_sphere_001 = attr_vis.nodes.new("GeometryNodeMeshIcoSphere")
	#Radius
	ico_sphere_001.inputs[0].default_value = 1.0
	#Subdivisions
	ico_sphere_001.inputs[1].default_value = 2

	#node Instance on Points.001
	instance_on_points_001 = attr_vis.nodes.new("GeometryNodeInstanceOnPoints")
	#Pick Instance
	instance_on_points_001.inputs[3].default_value = False
	#Instance Index
	instance_on_points_001.inputs[4].default_value = 0
	#Rotation
	instance_on_points_001.inputs[5].default_value = (0.0, 0.0, 0.0)

	#node Set Shade Smooth
	set_shade_smooth = attr_vis.nodes.new("GeometryNodeSetShadeSmooth")
	#Selection
	set_shade_smooth.inputs[1].default_value = True
	#Shade Smooth
	set_shade_smooth.inputs[2].default_value = True

	#node Set Shade Smooth.001
	set_shade_smooth_001 = attr_vis.nodes.new("GeometryNodeSetShadeSmooth")
	#Selection
	set_shade_smooth_001.inputs[1].default_value = True
	#Shade Smooth
	set_shade_smooth_001.inputs[2].default_value = True

	#node Join Geometry
	join_geometry = attr_vis.nodes.new("GeometryNodeJoinGeometry")

	#node Cone
	cone = attr_vis.nodes.new("GeometryNodeMeshCone")
	cone.fill_type = 'NGON'
	#Vertices
	cone.inputs[0].default_value = 8
	#Side Segments
	cone.inputs[1].default_value = 1
	#Fill Segments
	cone.inputs[2].default_value = 1
	#Radius Top
	cone.inputs[3].default_value = 0.0
	#Radius Bottom
	cone.inputs[4].default_value = 1.0
	#Depth
	cone.inputs[5].default_value = 1.0

	#node Math.002
	math_002 = attr_vis.nodes.new("ShaderNodeMath")
	math_002.operation = 'COMPARE'
	#Value_001
	math_002.inputs[1].default_value = 0.0
	#Value_002
	math_002.inputs[2].default_value = 0.0010000000474974513

	#node Math.003
	math_003 = attr_vis.nodes.new("ShaderNodeMath")
	math_003.operation = 'GREATER_THAN'
	#Value_001
	math_003.inputs[1].default_value = 0.0
	#Value_002
	math_003.inputs[2].default_value = 0.0010000000474974513

	#node Named Attribute
	named_attribute = attr_vis.nodes.new("GeometryNodeInputNamedAttribute")
	named_attribute.data_type = 'FLOAT'

	#node Instance on Points
	instance_on_points = attr_vis.nodes.new("GeometryNodeInstanceOnPoints")
	#Pick Instance
	instance_on_points.inputs[3].default_value = False
	#Instance Index
	instance_on_points.inputs[4].default_value = 0
	#Rotation
	instance_on_points.inputs[5].default_value = (0.0, 0.0, 0.0)

	#node Boolean Math
	boolean_math = attr_vis.nodes.new("FunctionNodeBooleanMath")
	boolean_math.operation = 'AND'

	#node Evaluate on Domain
	evaluate_on_domain = attr_vis.nodes.new("GeometryNodeFieldOnDomain")
	evaluate_on_domain.data_type = 'FLOAT'
	evaluate_on_domain.domain = 'POINT'
	#Value_Int
	evaluate_on_domain.inputs[1].default_value = 0
	#Value_Vector
	evaluate_on_domain.inputs[2].default_value = (0.0, 0.0, 0.0)
	#Value_Color
	evaluate_on_domain.inputs[3].default_value = (0.0, 0.0, 0.0, 0.0)
	#Value_Bool
	evaluate_on_domain.inputs[4].default_value = False

	#attr_vis inputs
	#input Geometry
	attr_vis.inputs.new('NodeSocketGeometry', "Geometry")
	attr_vis.inputs[0].attribute_domain = 'POINT'

	#input Size
	attr_vis.inputs.new('NodeSocketFloat', "Size")
	attr_vis.inputs[1].default_value = 1.0
	attr_vis.inputs[1].min_value = 0.0
	attr_vis.inputs[1].max_value = 3.4028234663852886e+38
	attr_vis.inputs[1].attribute_domain = 'POINT'

	#input Vis Scale
	attr_vis.inputs.new('NodeSocketFloat', "Vis Scale")
	attr_vis.inputs[2].default_value = 1.0
	attr_vis.inputs[2].min_value = 0.0
	attr_vis.inputs[2].max_value = 3.4028234663852886e+38
	attr_vis.inputs[2].attribute_domain = 'POINT'

	#input Vis Invert
	attr_vis.inputs.new('NodeSocketBool', "Vis Invert")
	attr_vis.inputs[3].default_value = False
	attr_vis.inputs[3].attribute_domain = 'POINT'

	#input V_attr_name
	attr_vis.inputs.new('NodeSocketString', "V_attr_name")
	attr_vis.inputs[4].attribute_domain = 'POINT'

	#input E_attr_name
	attr_vis.inputs.new('NodeSocketString', "E_attr_name")
	attr_vis.inputs[5].attribute_domain = 'POINT'


	#node Group Input
	group_input = attr_vis.nodes.new("NodeGroupInput")

	#node Math.004
	math_004 = attr_vis.nodes.new("ShaderNodeMath")
	math_004.operation = 'MULTIPLY'
	#Value_002
	math_004.inputs[2].default_value = 0.5

	#node Evaluate on Domain.001
	evaluate_on_domain_001 = attr_vis.nodes.new("GeometryNodeFieldOnDomain")
	evaluate_on_domain_001.data_type = 'FLOAT'
	evaluate_on_domain_001.domain = 'POINT'
	#Value_Int
	evaluate_on_domain_001.inputs[1].default_value = 0
	#Value_Vector
	evaluate_on_domain_001.inputs[2].default_value = (0.0, 0.0, 0.0)
	#Value_Color
	evaluate_on_domain_001.inputs[3].default_value = (0.0, 0.0, 0.0, 0.0)
	#Value_Bool
	evaluate_on_domain_001.inputs[4].default_value = False

	#node Set Curve Radius
	set_curve_radius = attr_vis.nodes.new("GeometryNodeSetCurveRadius")
	#Selection
	set_curve_radius.inputs[1].default_value = True

	#node Mesh to Curve.001
	mesh_to_curve_001 = attr_vis.nodes.new("GeometryNodeMeshToCurve")

	#node Curve Circle
	curve_circle = attr_vis.nodes.new("GeometryNodeCurvePrimitiveCircle")
	curve_circle.mode = 'RADIUS'
	#Resolution
	curve_circle.inputs[0].default_value = 6
	#Point 1
	curve_circle.inputs[1].default_value = (-1.0, 0.0, 0.0)
	#Point 2
	curve_circle.inputs[2].default_value = (0.0, 1.0, 0.0)
	#Point 3
	curve_circle.inputs[3].default_value = (1.0, 0.0, 0.0)
	#Radius
	curve_circle.inputs[4].default_value = 0.5

	#node Curve to Mesh.001
	curve_to_mesh_001 = attr_vis.nodes.new("GeometryNodeCurveToMesh")
	#Fill Caps
	curve_to_mesh_001.inputs[2].default_value = False

	#node Switch
	switch = attr_vis.nodes.new("GeometryNodeSwitch")
	switch.input_type = 'GEOMETRY'
	#Switch
	switch.inputs[0].default_value = False
	#False
	switch.inputs[2].default_value = 0.0
	#True
	switch.inputs[3].default_value = 0.0
	#False_001
	switch.inputs[4].default_value = 0
	#True_001
	switch.inputs[5].default_value = 0
	#False_002
	switch.inputs[6].default_value = False
	#True_002
	switch.inputs[7].default_value = True
	#False_003
	switch.inputs[8].default_value = (0.0, 0.0, 0.0)
	#True_003
	switch.inputs[9].default_value = (0.0, 0.0, 0.0)
	#False_004
	switch.inputs[10].default_value = (0.800000011920929, 0.800000011920929, 0.800000011920929, 1.0)
	#True_004
	switch.inputs[11].default_value = (0.800000011920929, 0.800000011920929, 0.800000011920929, 1.0)
	#False_005
	switch.inputs[12].default_value = ""
	#True_005
	switch.inputs[13].default_value = ""

	#attr_vis outputs
	#output Geometry
	attr_vis.outputs.new('NodeSocketGeometry', "Geometry")
	attr_vis.outputs[0].attribute_domain = 'POINT'


	#node Group Output
	group_output = attr_vis.nodes.new("NodeGroupOutput")


	#Set locations
	named_attribute_001.location = (-260.0, -380.0)
	attribute_statistic.location = (-40.0, -20.0)
	ico_sphere_001.location = (700.0, 240.0)
	instance_on_points_001.location = (1060.0, 340.0)
	set_shade_smooth.location = (880.0, 240.0)
	set_shade_smooth_001.location = (880.0, 80.0)
	join_geometry.location = (1360.0, -20.0)
	cone.location = (700.0, 100.0)
	math_002.location = (200.0, 140.0)
	math_003.location = (200.0, 320.3078918457031)
	named_attribute.location = (-260.0, -100.0)
	instance_on_points.location = (1060.0, 0.0)
	boolean_math.location = (440.0, 320.0)
	evaluate_on_domain.location = (180.0, -100.0)
	group_input.location = (-900.0, 0.0)
	math_004.location = (460.0, -540.0)
	evaluate_on_domain_001.location = (180.0, -380.0)
	set_curve_radius.location = (1200.0, -460.0)
	mesh_to_curve_001.location = (1040.0, -460.0)
	curve_circle.location = (1200.0, -600.0)
	curve_to_mesh_001.location = (1360.0, -460.0)
	switch.location = (1780.0, -220.0)
	group_output.location = (2060.0, -240.0)

	#Set dimensions
	named_attribute_001.width, named_attribute_001.height = 140.0, 100.0
	attribute_statistic.width, attribute_statistic.height = 140.0, 100.0
	ico_sphere_001.width, ico_sphere_001.height = 140.0, 100.0
	instance_on_points_001.width, instance_on_points_001.height = 140.0, 100.0
	set_shade_smooth.width, set_shade_smooth.height = 140.0, 100.0
	set_shade_smooth_001.width, set_shade_smooth_001.height = 140.0, 100.0
	join_geometry.width, join_geometry.height = 140.0, 100.0
	cone.width, cone.height = 140.0, 100.0
	math_002.width, math_002.height = 140.0, 100.0
	math_003.width, math_003.height = 140.0, 100.0
	named_attribute.width, named_attribute.height = 140.0, 100.0
	instance_on_points.width, instance_on_points.height = 140.0, 100.0
	boolean_math.width, boolean_math.height = 140.0, 100.0
	evaluate_on_domain.width, evaluate_on_domain.height = 140.0, 100.0
	group_input.width, group_input.height = 140.0, 100.0
	math_004.width, math_004.height = 140.0, 100.0
	evaluate_on_domain_001.width, evaluate_on_domain_001.height = 140.0, 100.0
	set_curve_radius.width, set_curve_radius.height = 140.0, 100.0
	mesh_to_curve_001.width, mesh_to_curve_001.height = 140.0, 100.0
	curve_circle.width, curve_circle.height = 140.0, 100.0
	curve_to_mesh_001.width, curve_to_mesh_001.height = 140.0, 100.0
	switch.width, switch.height = 140.0, 100.0
	group_output.width, group_output.height = 140.0, 100.0

	#initialize attr_vis links
	#group_input.V_attr_name -> named_attribute.Name
	attr_vis.links.new(group_input.outputs[4], named_attribute.inputs[0])
	#named_attribute_001.Attribute -> evaluate_on_domain_001.Value
	attr_vis.links.new(named_attribute_001.outputs[1], evaluate_on_domain_001.inputs[0])
	#group_input.E_attr_name -> named_attribute_001.Name
	attr_vis.links.new(group_input.outputs[5], named_attribute_001.inputs[0])
	#group_input.Geometry -> instance_on_points.Points
	attr_vis.links.new(group_input.outputs[0], instance_on_points.inputs[0])
	#group_input.Geometry -> attribute_statistic.Geometry
	attr_vis.links.new(group_input.outputs[0], attribute_statistic.inputs[0])
	#named_attribute.Attribute -> evaluate_on_domain.Value
	attr_vis.links.new(named_attribute.outputs[1], evaluate_on_domain.inputs[0])
	#attribute_statistic.Max -> switch.Switch
	attr_vis.links.new(attribute_statistic.outputs[4], switch.inputs[1])
	#instance_on_points_001.Instances -> join_geometry.Geometry
	attr_vis.links.new(instance_on_points_001.outputs[0], join_geometry.inputs[0])
	#join_geometry.Geometry -> switch.True
	attr_vis.links.new(join_geometry.outputs[0], switch.inputs[15])
	#set_shade_smooth.Geometry -> instance_on_points_001.Instance
	attr_vis.links.new(set_shade_smooth.outputs[0], instance_on_points_001.inputs[2])
	#ico_sphere_001.Mesh -> set_shade_smooth.Geometry
	attr_vis.links.new(ico_sphere_001.outputs[0], set_shade_smooth.inputs[0])
	#set_shade_smooth_001.Geometry -> instance_on_points.Instance
	attr_vis.links.new(set_shade_smooth_001.outputs[0], instance_on_points.inputs[2])
	#cone.Mesh -> set_shade_smooth_001.Geometry
	attr_vis.links.new(cone.outputs[0], set_shade_smooth_001.inputs[0])
	#evaluate_on_domain.Value -> math_002.Value
	attr_vis.links.new(evaluate_on_domain.outputs[0], math_002.inputs[0])
	#math_002.Value -> instance_on_points.Selection
	attr_vis.links.new(math_002.outputs[0], instance_on_points.inputs[1])
	#named_attribute.Attribute -> attribute_statistic.Attribute
	attr_vis.links.new(named_attribute.outputs[1], attribute_statistic.inputs[2])
	#evaluate_on_domain.Value -> math_003.Value
	attr_vis.links.new(evaluate_on_domain.outputs[0], math_003.inputs[0])
	#group_input.Geometry -> instance_on_points_001.Points
	attr_vis.links.new(group_input.outputs[0], instance_on_points_001.inputs[0])
	#boolean_math.Boolean -> instance_on_points_001.Selection
	attr_vis.links.new(boolean_math.outputs[0], instance_on_points_001.inputs[1])
	#instance_on_points.Instances -> join_geometry.Geometry
	attr_vis.links.new(instance_on_points.outputs[0], join_geometry.inputs[0])
	#math_003.Value -> boolean_math.Boolean
	attr_vis.links.new(math_003.outputs[0], boolean_math.inputs[0])
	#group_input.Vis Invert -> boolean_math.Boolean
	attr_vis.links.new(group_input.outputs[3], boolean_math.inputs[1])
	#group_input.Vis Scale -> instance_on_points.Scale
	attr_vis.links.new(group_input.outputs[2], instance_on_points.inputs[6])
	#evaluate_on_domain.Value -> instance_on_points_001.Scale
	attr_vis.links.new(evaluate_on_domain.outputs[0], instance_on_points_001.inputs[6])
	#evaluate_on_domain_001.Value -> math_004.Value
	attr_vis.links.new(evaluate_on_domain_001.outputs[0], math_004.inputs[0])
	#group_input.Vis Scale -> math_004.Value
	attr_vis.links.new(group_input.outputs[2], math_004.inputs[1])
	#mesh_to_curve_001.Curve -> set_curve_radius.Curve
	attr_vis.links.new(mesh_to_curve_001.outputs[0], set_curve_radius.inputs[0])
	#set_curve_radius.Curve -> curve_to_mesh_001.Curve
	attr_vis.links.new(set_curve_radius.outputs[0], curve_to_mesh_001.inputs[0])
	#curve_circle.Curve -> curve_to_mesh_001.Profile Curve
	attr_vis.links.new(curve_circle.outputs[0], curve_to_mesh_001.inputs[1])
	#switch.Output -> group_output.Geometry
	attr_vis.links.new(switch.outputs[6], group_output.inputs[0])
	#math_004.Value -> set_curve_radius.Radius
	attr_vis.links.new(math_004.outputs[0], set_curve_radius.inputs[2])
	#curve_to_mesh_001.Mesh -> switch.False
	attr_vis.links.new(curve_to_mesh_001.outputs[0], switch.inputs[14])
	#evaluate_on_domain_001.Value -> mesh_to_curve_001.Selection
	attr_vis.links.new(evaluate_on_domain_001.outputs[0], mesh_to_curve_001.inputs[1])
	#group_input.Geometry -> mesh_to_curve_001.Mesh
	attr_vis.links.new(group_input.outputs[0], mesh_to_curve_001.inputs[0])
	attr_vis.use_fake_user = True
	return attr_vis

def GetGeoNode():
    if "Attr_Vis" in bpy.data.node_groups:
        return bpy.data.node_groups["Attr_Vis"]
    else:
        return attr_vis_node_group()
