### CapsuleGenGeoNode.py ###
# Automatically generated by NodeToPython Addon: https://github.com/BrendanParmer/NodeToPython/releases/tag/v2.2.0

import bpy
import bpy
def attr_vis_node_group():
	attr_vis= bpy.data.node_groups.new(type = 'GeometryNodeTree', name = "Attr_Vis")

	#initialize attr_vis nodes
	#node Ico Sphere
	ico_sphere = attr_vis.nodes.new("GeometryNodeMeshIcoSphere")
	#Radius
	ico_sphere.inputs[0].default_value = 1.0
	#Subdivisions
	ico_sphere.inputs[1].default_value = 2

	#node Instance on Points
	instance_on_points = attr_vis.nodes.new("GeometryNodeInstanceOnPoints")
	#Pick Instance
	instance_on_points.inputs[3].default_value = False
	#Instance Index
	instance_on_points.inputs[4].default_value = 0
	#Rotation
	instance_on_points.inputs[5].default_value = (0.0, 0.0, 0.0)

	#node Set Shade Smooth
	set_shade_smooth = attr_vis.nodes.new("GeometryNodeSetShadeSmooth")
	#Selection
	set_shade_smooth.inputs[1].default_value = True
	#Shade Smooth
	set_shade_smooth.inputs[2].default_value = True

	#node Set Shade Smooth.001
	set_shade_smooth_001 = attr_vis.nodes.new("GeometryNodeSetShadeSmooth")
	#Selection
	set_shade_smooth_001.inputs[1].default_value = True
	#Shade Smooth
	set_shade_smooth_001.inputs[2].default_value = True

	#node Join Geometry
	join_geometry = attr_vis.nodes.new("GeometryNodeJoinGeometry")

	#node Cone
	cone = attr_vis.nodes.new("GeometryNodeMeshCone")
	cone.fill_type = 'NGON'
	#Vertices
	cone.inputs[0].default_value = 8
	#Side Segments
	cone.inputs[1].default_value = 1
	#Fill Segments
	cone.inputs[2].default_value = 1
	#Radius Top
	cone.inputs[3].default_value = 0.0
	#Radius Bottom
	cone.inputs[4].default_value = 1.0
	#Depth
	cone.inputs[5].default_value = 1.0

	#node Math
	math = attr_vis.nodes.new("ShaderNodeMath")
	math.operation = 'COMPARE'
	#Value_001
	math.inputs[1].default_value = 0.0
	#Value_002
	math.inputs[2].default_value = 0.0010000000474974513

	#node Math.001
	math_001 = attr_vis.nodes.new("ShaderNodeMath")
	math_001.operation = 'GREATER_THAN'
	#Value_001
	math_001.inputs[1].default_value = 0.0
	#Value_002
	math_001.inputs[2].default_value = 0.0010000000474974513

	#node Instance on Points.001
	instance_on_points_001 = attr_vis.nodes.new("GeometryNodeInstanceOnPoints")
	#Pick Instance
	instance_on_points_001.inputs[3].default_value = False
	#Instance Index
	instance_on_points_001.inputs[4].default_value = 0
	#Rotation
	instance_on_points_001.inputs[5].default_value = (0.0, 0.0, 0.0)

	#node Boolean Math
	boolean_math = attr_vis.nodes.new("FunctionNodeBooleanMath")
	boolean_math.operation = 'AND'

	#attr_vis outputs
	#output Geometry
	attr_vis.outputs.new('NodeSocketGeometry', "Geometry")
	attr_vis.outputs[0].attribute_domain = 'POINT'


	#node Group Output
	group_output = attr_vis.nodes.new("NodeGroupOutput")

	#node Mesh to Curve.002
	mesh_to_curve_002 = attr_vis.nodes.new("GeometryNodeMeshToCurve")
	#Selection
	mesh_to_curve_002.inputs[1].default_value = True

	#node Delete Geometry
	delete_geometry = attr_vis.nodes.new("GeometryNodeDeleteGeometry")
	delete_geometry.domain = 'EDGE'
	delete_geometry.mode = 'EDGE_FACE'

	#node Delete Geometry.001
	delete_geometry_001 = attr_vis.nodes.new("GeometryNodeDeleteGeometry")
	delete_geometry_001.domain = 'POINT'
	delete_geometry_001.mode = 'ONLY_FACE'
	#Selection
	delete_geometry_001.inputs[1].default_value = True

	#node Named Attribute
	named_attribute = attr_vis.nodes.new("GeometryNodeInputNamedAttribute")
	named_attribute.data_type = 'FLOAT'

	#node Boolean Math.001
	boolean_math_001 = attr_vis.nodes.new("FunctionNodeBooleanMath")
	boolean_math_001.operation = 'NOT'
	#Boolean_001
	boolean_math_001.inputs[1].default_value = False

	#node Split Edges
	split_edges = attr_vis.nodes.new("GeometryNodeSplitEdges")
	#Selection
	split_edges.inputs[1].default_value = True

	#node Evaluate on Domain.001
	evaluate_on_domain_001 = attr_vis.nodes.new("GeometryNodeFieldOnDomain")
	evaluate_on_domain_001.data_type = 'FLOAT'
	evaluate_on_domain_001.domain = 'EDGE'
	#Value_Int
	evaluate_on_domain_001.inputs[1].default_value = 0
	#Value_Vector
	evaluate_on_domain_001.inputs[2].default_value = (0.0, 0.0, 0.0)
	#Value_Color
	evaluate_on_domain_001.inputs[3].default_value = (0.0, 0.0, 0.0, 0.0)
	#Value_Bool
	evaluate_on_domain_001.inputs[4].default_value = False

	#node Curve Circle
	curve_circle = attr_vis.nodes.new("GeometryNodeCurvePrimitiveCircle")
	curve_circle.mode = 'RADIUS'
	#Resolution
	curve_circle.inputs[0].default_value = 6
	#Point 1
	curve_circle.inputs[1].default_value = (-1.0, 0.0, 0.0)
	#Point 2
	curve_circle.inputs[2].default_value = (0.0, 1.0, 0.0)
	#Point 3
	curve_circle.inputs[3].default_value = (1.0, 0.0, 0.0)
	#Radius
	curve_circle.inputs[4].default_value = 1.0

	#node Set Curve Radius
	set_curve_radius = attr_vis.nodes.new("GeometryNodeSetCurveRadius")
	#Selection
	set_curve_radius.inputs[1].default_value = True

	#node Evaluate on Domain.002
	evaluate_on_domain_002 = attr_vis.nodes.new("GeometryNodeFieldOnDomain")
	evaluate_on_domain_002.data_type = 'FLOAT'
	evaluate_on_domain_002.domain = 'CURVE'
	#Value_Int
	evaluate_on_domain_002.inputs[1].default_value = 0
	#Value_Vector
	evaluate_on_domain_002.inputs[2].default_value = (0.0, 0.0, 0.0)
	#Value_Color
	evaluate_on_domain_002.inputs[3].default_value = (0.0, 0.0, 0.0, 0.0)
	#Value_Bool
	evaluate_on_domain_002.inputs[4].default_value = False

	#node Math.002
	math_002 = attr_vis.nodes.new("ShaderNodeMath")
	math_002.operation = 'MULTIPLY'
	#Value_002
	math_002.inputs[2].default_value = 0.5

	#node Math.003
	math_003 = attr_vis.nodes.new("ShaderNodeMath")
	math_003.operation = 'MULTIPLY'
	#Value_001
	math_003.inputs[1].default_value = 0.5
	#Value_002
	math_003.inputs[2].default_value = 0.5

	#node Curve to Mesh
	curve_to_mesh = attr_vis.nodes.new("GeometryNodeCurveToMesh")
	#Fill Caps
	curve_to_mesh.inputs[2].default_value = False

	#node Switch
	switch = attr_vis.nodes.new("GeometryNodeSwitch")
	switch.input_type = 'GEOMETRY'
	#Switch
	switch.inputs[0].default_value = False
	#False
	switch.inputs[2].default_value = 0.0
	#True
	switch.inputs[3].default_value = 0.0
	#False_001
	switch.inputs[4].default_value = 0
	#True_001
	switch.inputs[5].default_value = 0
	#False_002
	switch.inputs[6].default_value = False
	#True_002
	switch.inputs[7].default_value = True
	#False_003
	switch.inputs[8].default_value = (0.0, 0.0, 0.0)
	#True_003
	switch.inputs[9].default_value = (0.0, 0.0, 0.0)
	#False_004
	switch.inputs[10].default_value = (0.800000011920929, 0.800000011920929, 0.800000011920929, 1.0)
	#True_004
	switch.inputs[11].default_value = (0.800000011920929, 0.800000011920929, 0.800000011920929, 1.0)
	#False_005
	switch.inputs[12].default_value = ""
	#True_005
	switch.inputs[13].default_value = ""

	#attr_vis inputs
	#input Geometry
	attr_vis.inputs.new('NodeSocketGeometry', "Geometry")
	attr_vis.inputs[0].attribute_domain = 'POINT'

	#input Size
	attr_vis.inputs.new('NodeSocketFloat', "Size")
	attr_vis.inputs[1].default_value = 1.0
	attr_vis.inputs[1].min_value = 0.0
	attr_vis.inputs[1].max_value = 3.4028234663852886e+38
	attr_vis.inputs[1].attribute_domain = 'POINT'

	#input Vis Scale
	attr_vis.inputs.new('NodeSocketFloat', "Vis Scale")
	attr_vis.inputs[2].default_value = 1.0
	attr_vis.inputs[2].min_value = 0.0
	attr_vis.inputs[2].max_value = 3.4028234663852886e+38
	attr_vis.inputs[2].attribute_domain = 'POINT'

	#input Vis Invert
	attr_vis.inputs.new('NodeSocketBool', "Vis Invert")
	attr_vis.inputs[3].default_value = False
	attr_vis.inputs[3].attribute_domain = 'POINT'

	#input V_attr_name
	attr_vis.inputs.new('NodeSocketString', "V_attr_name")
	attr_vis.inputs[4].attribute_domain = 'POINT'

	#input E_attr_name
	attr_vis.inputs.new('NodeSocketString', "E_attr_name")
	attr_vis.inputs[5].attribute_domain = 'POINT'


	#node Group Input.001
	group_input_001 = attr_vis.nodes.new("NodeGroupInput")

	#node Group Input.002
	group_input_002 = attr_vis.nodes.new("NodeGroupInput")

	#node Attribute Statistic.001
	attribute_statistic_001 = attr_vis.nodes.new("GeometryNodeAttributeStatistic")
	attribute_statistic_001.data_type = 'FLOAT'
	attribute_statistic_001.domain = 'POINT'
	#Selection
	attribute_statistic_001.inputs[1].default_value = True
	#Attribute_001
	attribute_statistic_001.inputs[3].default_value = (0.0, 0.0, 0.0)

	#node Named Attribute.002
	named_attribute_002 = attr_vis.nodes.new("GeometryNodeInputNamedAttribute")
	named_attribute_002.data_type = 'FLOAT'

	#node Group Input
	group_input = attr_vis.nodes.new("NodeGroupInput")

	#node Named Attribute.003
	named_attribute_003 = attr_vis.nodes.new("GeometryNodeInputNamedAttribute")
	named_attribute_003.data_type = 'FLOAT'

	#node Evaluate on Domain
	evaluate_on_domain = attr_vis.nodes.new("GeometryNodeFieldOnDomain")
	evaluate_on_domain.data_type = 'FLOAT'
	evaluate_on_domain.domain = 'POINT'
	#Value_Int
	evaluate_on_domain.inputs[1].default_value = 0
	#Value_Vector
	evaluate_on_domain.inputs[2].default_value = (0.0, 0.0, 0.0)
	#Value_Color
	evaluate_on_domain.inputs[3].default_value = (0.0, 0.0, 0.0, 0.0)
	#Value_Bool
	evaluate_on_domain.inputs[4].default_value = False


	#Set locations
	ico_sphere.location = (700.0, 240.0)
	instance_on_points.location = (1060.0, 340.0)
	set_shade_smooth.location = (880.0, 240.0)
	set_shade_smooth_001.location = (880.0, 80.0)
	join_geometry.location = (1360.0, -20.0)
	cone.location = (700.0, 100.0)
	math.location = (200.0, 140.0)
	math_001.location = (200.0, 320.3078918457031)
	instance_on_points_001.location = (1060.0, 0.0)
	boolean_math.location = (440.0, 320.0)
	group_output.location = (2060.0, -240.0)
	mesh_to_curve_002.location = (700.0, -640.0)
	delete_geometry.location = (340.0, -620.0)
	delete_geometry_001.location = (120.0, -580.0)
	named_attribute.location = (-260.0, -720.0)
	boolean_math_001.location = (120.0, -740.0)
	split_edges.location = (540.0, -640.0)
	evaluate_on_domain_001.location = (-80.0, -720.0)
	curve_circle.location = (860.0, -800.0)
	set_curve_radius.location = (860.0, -640.0)
	evaluate_on_domain_002.location = (-80.0, -860.0)
	math_002.location = (120.0, -860.0)
	math_003.location = (340.0, -860.0)
	curve_to_mesh.location = (1020.0, -720.0)
	switch.location = (1780.0, -220.0)
	group_input_001.location = (-640.0, -680.0)
	group_input_002.location = (840.0, -360.0)
	attribute_statistic_001.location = (1180.0, -300.0)
	named_attribute_002.location = (1000.0, -360.0)
	group_input.location = (-640.0, 0.0)
	named_attribute_003.location = (-260.0, -100.0)
	evaluate_on_domain.location = (-80.0, -100.0)

	#Set dimensions
	ico_sphere.width, ico_sphere.height = 140.0, 100.0
	instance_on_points.width, instance_on_points.height = 140.0, 100.0
	set_shade_smooth.width, set_shade_smooth.height = 140.0, 100.0
	set_shade_smooth_001.width, set_shade_smooth_001.height = 140.0, 100.0
	join_geometry.width, join_geometry.height = 140.0, 100.0
	cone.width, cone.height = 140.0, 100.0
	math.width, math.height = 140.0, 100.0
	math_001.width, math_001.height = 140.0, 100.0
	instance_on_points_001.width, instance_on_points_001.height = 140.0, 100.0
	boolean_math.width, boolean_math.height = 140.0, 100.0
	group_output.width, group_output.height = 140.0, 100.0
	mesh_to_curve_002.width, mesh_to_curve_002.height = 140.0, 100.0
	delete_geometry.width, delete_geometry.height = 140.0, 100.0
	delete_geometry_001.width, delete_geometry_001.height = 140.0, 100.0
	named_attribute.width, named_attribute.height = 140.0, 100.0
	boolean_math_001.width, boolean_math_001.height = 140.0, 100.0
	split_edges.width, split_edges.height = 140.0, 100.0
	evaluate_on_domain_001.width, evaluate_on_domain_001.height = 140.0, 100.0
	curve_circle.width, curve_circle.height = 140.0, 100.0
	set_curve_radius.width, set_curve_radius.height = 140.0, 100.0
	evaluate_on_domain_002.width, evaluate_on_domain_002.height = 140.0, 100.0
	math_002.width, math_002.height = 140.0, 100.0
	math_003.width, math_003.height = 140.0, 100.0
	curve_to_mesh.width, curve_to_mesh.height = 120.22119140625, 100.0
	switch.width, switch.height = 140.0, 100.0
	group_input_001.width, group_input_001.height = 140.0, 100.0
	group_input_002.width, group_input_002.height = 140.0, 100.0
	attribute_statistic_001.width, attribute_statistic_001.height = 140.0, 100.0
	named_attribute_002.width, named_attribute_002.height = 140.0, 100.0
	group_input.width, group_input.height = 140.0, 100.0
	named_attribute_003.width, named_attribute_003.height = 140.0, 100.0
	evaluate_on_domain.width, evaluate_on_domain.height = 140.0, 100.0

	#initialize attr_vis links
	#group_input.Geometry -> instance_on_points_001.Points
	attr_vis.links.new(group_input.outputs[0], instance_on_points_001.inputs[0])
	#instance_on_points.Instances -> join_geometry.Geometry
	attr_vis.links.new(instance_on_points.outputs[0], join_geometry.inputs[0])
	#join_geometry.Geometry -> switch.True
	attr_vis.links.new(join_geometry.outputs[0], switch.inputs[15])
	#set_shade_smooth.Geometry -> instance_on_points.Instance
	attr_vis.links.new(set_shade_smooth.outputs[0], instance_on_points.inputs[2])
	#ico_sphere.Mesh -> set_shade_smooth.Geometry
	attr_vis.links.new(ico_sphere.outputs[0], set_shade_smooth.inputs[0])
	#set_shade_smooth_001.Geometry -> instance_on_points_001.Instance
	attr_vis.links.new(set_shade_smooth_001.outputs[0], instance_on_points_001.inputs[2])
	#cone.Mesh -> set_shade_smooth_001.Geometry
	attr_vis.links.new(cone.outputs[0], set_shade_smooth_001.inputs[0])
	#evaluate_on_domain.Value -> math.Value
	attr_vis.links.new(evaluate_on_domain.outputs[0], math.inputs[0])
	#math.Value -> instance_on_points_001.Selection
	attr_vis.links.new(math.outputs[0], instance_on_points_001.inputs[1])
	#evaluate_on_domain.Value -> math_001.Value
	attr_vis.links.new(evaluate_on_domain.outputs[0], math_001.inputs[0])
	#group_input.Geometry -> instance_on_points.Points
	attr_vis.links.new(group_input.outputs[0], instance_on_points.inputs[0])
	#boolean_math.Boolean -> instance_on_points.Selection
	attr_vis.links.new(boolean_math.outputs[0], instance_on_points.inputs[1])
	#instance_on_points_001.Instances -> join_geometry.Geometry
	attr_vis.links.new(instance_on_points_001.outputs[0], join_geometry.inputs[0])
	#math_001.Value -> boolean_math.Boolean
	attr_vis.links.new(math_001.outputs[0], boolean_math.inputs[0])
	#group_input.Vis Invert -> boolean_math.Boolean
	attr_vis.links.new(group_input.outputs[3], boolean_math.inputs[1])
	#group_input.Vis Scale -> instance_on_points_001.Scale
	attr_vis.links.new(group_input.outputs[2], instance_on_points_001.inputs[6])
	#evaluate_on_domain.Value -> instance_on_points.Scale
	attr_vis.links.new(evaluate_on_domain.outputs[0], instance_on_points.inputs[6])
	#group_input_001.E_attr_name -> named_attribute.Name
	attr_vis.links.new(group_input_001.outputs[5], named_attribute.inputs[0])
	#named_attribute.Attribute -> evaluate_on_domain_001.Value
	attr_vis.links.new(named_attribute.outputs[1], evaluate_on_domain_001.inputs[0])
	#split_edges.Mesh -> mesh_to_curve_002.Mesh
	attr_vis.links.new(split_edges.outputs[0], mesh_to_curve_002.inputs[0])
	#delete_geometry_001.Geometry -> delete_geometry.Geometry
	attr_vis.links.new(delete_geometry_001.outputs[0], delete_geometry.inputs[0])
	#group_input_001.Geometry -> delete_geometry_001.Geometry
	attr_vis.links.new(group_input_001.outputs[0], delete_geometry_001.inputs[0])
	#boolean_math_001.Boolean -> delete_geometry.Selection
	attr_vis.links.new(boolean_math_001.outputs[0], delete_geometry.inputs[1])
	#evaluate_on_domain_001.Value -> boolean_math_001.Boolean
	attr_vis.links.new(evaluate_on_domain_001.outputs[0], boolean_math_001.inputs[0])
	#delete_geometry.Geometry -> split_edges.Mesh
	attr_vis.links.new(delete_geometry.outputs[0], split_edges.inputs[0])
	#named_attribute.Attribute -> evaluate_on_domain_002.Value
	attr_vis.links.new(named_attribute.outputs[1], evaluate_on_domain_002.inputs[0])
	#mesh_to_curve_002.Curve -> set_curve_radius.Curve
	attr_vis.links.new(mesh_to_curve_002.outputs[0], set_curve_radius.inputs[0])
	#curve_circle.Curve -> curve_to_mesh.Profile Curve
	attr_vis.links.new(curve_circle.outputs[0], curve_to_mesh.inputs[1])
	#set_curve_radius.Curve -> curve_to_mesh.Curve
	attr_vis.links.new(set_curve_radius.outputs[0], curve_to_mesh.inputs[0])
	#group_input_001.Vis Scale -> math_002.Value
	attr_vis.links.new(group_input_001.outputs[2], math_002.inputs[1])
	#evaluate_on_domain_002.Value -> math_002.Value
	attr_vis.links.new(evaluate_on_domain_002.outputs[0], math_002.inputs[0])
	#math_003.Value -> set_curve_radius.Radius
	attr_vis.links.new(math_003.outputs[0], set_curve_radius.inputs[2])
	#math_002.Value -> math_003.Value
	attr_vis.links.new(math_002.outputs[0], math_003.inputs[0])
	#curve_to_mesh.Mesh -> switch.False
	attr_vis.links.new(curve_to_mesh.outputs[0], switch.inputs[14])
	#switch.Output -> group_output.Geometry
	attr_vis.links.new(switch.outputs[6], group_output.inputs[0])
	#group_input_002.V_attr_name -> named_attribute_002.Name
	attr_vis.links.new(group_input_002.outputs[4], named_attribute_002.inputs[0])
	#named_attribute_002.Attribute -> attribute_statistic_001.Attribute
	attr_vis.links.new(named_attribute_002.outputs[1], attribute_statistic_001.inputs[2])
	#group_input_002.Geometry -> attribute_statistic_001.Geometry
	attr_vis.links.new(group_input_002.outputs[0], attribute_statistic_001.inputs[0])
	#attribute_statistic_001.Max -> switch.Switch
	attr_vis.links.new(attribute_statistic_001.outputs[4], switch.inputs[1])
	#group_input.V_attr_name -> named_attribute_003.Name
	attr_vis.links.new(group_input.outputs[4], named_attribute_003.inputs[0])
	#named_attribute_003.Attribute -> evaluate_on_domain.Value
	attr_vis.links.new(named_attribute_003.outputs[1], evaluate_on_domain.inputs[0])
	attr_vis.use_fake_user = True
	return attr_vis

class Attr_Vis(bpy.types.Operator):
	bl_idname = "object.geo_node_attr_vis"
	bl_label = "Attr_Vis"
	bl_options = {'REGISTER', 'UNDO'}

	def execute(self, context):
		if "Attr_Vis" in bpy.data.node_groups:
			return {'FINISHED'}
		attr_vis = attr_vis_node_group()

		return {'FINISHED'}

def register():
	bpy.utils.register_class(Attr_Vis)

def unregister():
	bpy.utils.unregister_class(Attr_Vis)

def GetGeoNode():
    if "Attr_Vis" in bpy.data.node_groups:
        return bpy.data.node_groups["Attr_Vis"]
    else:
        return attr_vis_node_group()
	#bpy.ops.object.geo_node_attr_vis()
	#return bpy.data.node_groups["Attr_Vis"]
